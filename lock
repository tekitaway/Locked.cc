local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Locked.cc | Made By tekitaway",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Locked.cc",
   LoadingSubtitle = "by tekitaway",
   Theme = "DarkBlue", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = False,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "1llusion Hub"
   },

   Discord = {
      Enabled = True, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "YzsnvQyZB7", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = True -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab("🔫 Aimlocks", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Lock")

Rayfield:Notify({
   Title = "Script Executed | Locked.cc",
   Content = "By tekitaway",
   Duration = 3.5,
   Image = nil,
})

local Button = MainTab:CreateButton({
   Name = "Legit Camlock [q]",
   Callback = function()
        --// SETTINGS
local CAMLOCK_KEY = Enum.KeyCode.Q           -- Key to toggle camlock
local AIM_PART = "UpperTorso"          -- "Head" or "HumanoidRootPart"
local FOV_RADIUS = 100                        -- FOV radius (pixels)
local PREDICTION = 0.319                     -- Adjust for your ping/projectile speed
local SMOOTHNESS = 0.054                      -- Lower = snappier, higher = smoother

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

--// STATE
local camlockEnabled = false
local lockedTarget = nil

--// FOV CIRCLE (Visual Feedback)
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FOV_RADIUS
fovCircle.Color = Color3.fromRGB(0, 255, 255)
fovCircle.Filled = false
fovCircle.Visible = False

--// Helper: Find Closest Target in FOV
local function getClosestTarget()
    local closest, shortest = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(AIM_PART) and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local part = player.Character[AIM_PART]
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < FOV_RADIUS and dist < shortest then
                    closest = player
                    shortest = dist
                end
            end
        end
    end
    return closest
end

--// Main Camlock Logic
RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
    fovCircle.Visible = camlockEnabled

    if camlockEnabled then
        if not lockedTarget or not lockedTarget.Character or not lockedTarget.Character:FindFirstChild(AIM_PART) or lockedTarget.Character.Humanoid.Health <= 0 then
            lockedTarget = getClosestTarget()
        end
        if lockedTarget and lockedTarget.Character and lockedTarget.Character:FindFirstChild(AIM_PART) then
            local part = lockedTarget.Character[AIM_PART]
            local predicted = part.Position + (part.Velocity * PREDICTION)
            local camPos = Camera.CFrame.Position
            local newLook = (predicted - camPos).Unit
            local currentLook = Camera.CFrame.LookVector
            local lerpedLook = currentLook:Lerp(newLook, 1 - SMOOTHNESS)
            Camera.CFrame = CFrame.new(camPos, camPos + lerpedLook)
        end
    else
        lockedTarget = nil
    end
end)

--// Keybind Toggle
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == CAMLOCK_KEY then
        camlockEnabled = not camlockEnabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Camlock",
            Text = camlockEnabled and "ENABLED" or "DISABLED",
            Duration = 0.5
        })
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Aim Assist [locks on everything in its radius] (Q)",
   Callback = function()
        --// SETTINGS
local AIM_ASSIST_KEY = Enum.KeyCode.Q      -- Key to toggle aim assist
local AIM_PART = "UpperTorso"        -- "Head" or "HumanoidRootPart"
local FOV_RADIUS = 80                      -- Aim assist field of view radius (pixels)
local ASSIST_STRENGTH = 1              -- Lower = snappier, higher = smoother (0.1-0.3 recommended)

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

--// STATE
local assistEnabled = false

--// FOV CIRCLE (Optional Visual)
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FOV_RADIUS
fovCircle.Color = Color3.fromRGB(0, 170, 255)
fovCircle.Filled = false
fovCircle.Visible = true

--// Helper: Find Closest Target in FOV
local function getClosestTarget()
    local closest, shortest = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(AIM_PART) then
            local part = player.Character[AIM_PART]
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < FOV_RADIUS and dist < shortest then
                    closest = player
                    shortest = dist
                end
            end
        end
    end
    return closest
end

--// Main Aim Assist Logic
RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
    fovCircle.Visible = assistEnabled

    if assistEnabled then
        local target = getClosestTarget()
        if target and target.Character and target.Character:FindFirstChild(AIM_PART) then
            local targetPart = target.Character[AIM_PART]
            local camPos = Camera.CFrame.Position
            local newLook = (targetPart.Position - camPos).Unit
            local currentLook = Camera.CFrame.LookVector
            local lerpedLook = currentLook:Lerp(newLook, 1 - ASSIST_STRENGTH)
            Camera.CFrame = CFrame.new(camPos, camPos + lerpedLook)
        end
    end
end)

--// Toggle Keybind
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == AIM_ASSIST_KEY then
        assistEnabled = not assistEnabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Aim Assist",
            Text = assistEnabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Target Aim [c]",
   Callback = function()
       --// SETTINGS
getgenv().Prediction = 0.112         -- Adjust for your game's projectile speed and ping
getgenv().AimPart = "UpperTorso" -- "Head" or "HumanoidRootPart"
getgenv().Key = "c"                 -- Key to lock onto target
getgenv().DisableKey = "P"          -- Key to enable/disable aimlock
getgenv().FOV = true                -- Enable FOV circle
getgenv().ShowFOV = true            -- Show FOV circle on screen
getgenv().FOVSize = 55              -- FOV circle radius

--// SERVICES
local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera

--// STATE
local AimlockState = true
local Locked = false
local Victim = nil

--// FOV CIRCLE
local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 255, 0)
fov.NumSides = 1000

function updateFOV()
    if getgenv().FOV then
        fov.Radius = getgenv().FOVSize * 2
        fov.Visible = getgenv().ShowFOV
        fov.Position = Vector2.new(Mouse.X, Mouse.Y + GS:GetGuiInset().Y)
    else
        fov.Visible = false
    end
end

--// CLOSEST PLAYER FUNCTION
function getClosest()
    local closestPlayer
    local shortestDistance = math.huge
    for i, v in pairs(Players:GetPlayers()) do
        if v ~= LP and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild(getgenv().AimPart) then
            local pos = Camera:WorldToViewportPoint(v.Character[getgenv().AimPart].Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
            if (getgenv().FOV and fov.Radius > magnitude and magnitude < shortestDistance) or (not getgenv().FOV and magnitude < shortestDistance) then
                closestPlayer = v
                shortestDistance = magnitude
            end
        end
    end
    return closestPlayer
end

--// KEYBINDS
Mouse.KeyDown:Connect(function(k)
    if k:lower() == getgenv().Key:lower() then
        if AimlockState then
            Locked = not Locked
            if Locked then
                Victim = getClosest()
                SG:SetCore("SendNotification", {Title = "Aimlock", Text = "Locked onto: " .. (Victim and Victim.Name or "None"), Duration = 3})
            else
                Victim = nil
                SG:SetCore("SendNotification", {Title = "Aimlock", Text = "Unlocked", Duration = 2})
            end
        end
    elseif k:lower() == getgenv().DisableKey:lower() then
        AimlockState = not AimlockState
        SG:SetCore("SendNotification", {Title = "Aimlock", Text = AimlockState and "Enabled" or "Disabled", Duration = 2})
    end
end)

--// MAIN LOOP
RS.RenderStepped:Connect(function()
    updateFOV()
    if AimlockState and Locked and Victim and Victim.Character and Victim.Character:FindFirstChild(getgenv().AimPart) then
        local part = Victim.Character[getgenv().AimPart]
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, part.Position + part.Velocity * getgenv().Prediction)
    end
end)
   end,
})

local Button = MainTab:CreateButton({
   Name = "Fake Silent Aim [c] (works on some fake dahoods)",
   Callback = function()
        --// SETTINGS
local FakeSilentAimEnabled = false
local FakeSilentAimFOV = 120
local FakeSilentAimPart = "Head"

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local StarterGui = game:GetService("StarterGui")

--// FOV CIRCLE (Visual Only)
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = FakeSilentAimFOV
fovCircle.Color = Color3.fromRGB(0, 255, 0)
fovCircle.Filled = false
fovCircle.Visible = true

--// Helper: Find Closest Target in FOV
local function getClosestTarget()
    local closest, shortest = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(FakeSilentAimPart) then
            local part = player.Character[FakeSilentAimPart]
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < FakeSilentAimFOV and dist < shortest then
                    closest = player
                    shortest = dist
                end
            end
        end
    end
    return closest
end

--// Visual Feedback: Highlight Target and Notifications
local highlight = Instance.new("Highlight")
highlight.FillColor = Color3.fromRGB(0, 255, 0)
highlight.FillTransparency = 0.7
highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
highlight.OutlineTransparency = 0.2
highlight.Enabled = True
highlight.Parent = workspace

RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Mouse.X, Mouse.Y + (game:GetService("GuiService"):GetGuiInset().Y))
    fovCircle.Visible = FakeSilentAimEnabled

    if FakeSilentAimEnabled then
        local target = getClosestTarget()
        if target and target.Character then
            highlight.Adornee = target.Character
            highlight.Enabled = true
            StarterGui:SetCore("nil", {
                Title = "Fake Silent Aim",
                Text = "Target: " .. target.Name,
                Duration = 0.5
            })
        else
            highlight.Enabled = false
        end
    else
        highlight.Enabled = false
    end
end)

--// Toggle Key (e.g., "C")
Mouse.KeyDown:Connect(function(key)
    if key:lower() == "c" then
        FakeSilentAimEnabled = not FakeSilentAimEnabled
        StarterGui:SetCore("SendNotification", {
            Title = "Fake Silent Aim",
            Text = FakeSilentAimEnabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)
    end,
})

local MainSection = MainTab:CreateSection("Blatant (IDGAF)")
local Button = MainTab:CreateButton({
   Name = "Kill Aura (v)",
   Callback = function()
        --// SETTINGS
local KILL_AURA_RADIUS = 150         -- Radius around player for kill aura (studs)
local ATTACK_INTERVAL = 0.11         -- Delay between attacks (seconds)
local ENABLE_KEY = Enum.KeyCode.V    -- Key to toggle kill aura

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

--// STATE
local enabled = false

--// Helper: Get Players in Kill Aura Radius
local function getPlayersInRadius()
    local targets = {}
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
        local myPos = LocalPlayer.Character.HumanoidRootPart.Position
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("Head") and player.Character.Humanoid.Health > 0 then
                local theirPos = player.Character.HumanoidRootPart.Position
                if (myPos - theirPos).Magnitude <= KILL_AURA_RADIUS then
                    table.insert(targets, player)
                end
            end
        end
    end
    return targets
end

--// Attack Logic (Replace with your game's system)
local function attackTarget(target)
    -- Example: For tool-based melee weapons
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("Activate") then
        tool:Activate()
    end

    -- Example: For remote-based combat (uncomment and adapt as needed)
    -- local remote = game:GetService("ReplicatedStorage"):FindFirstChild("AttackRemote")
    -- if remote and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
    --     remote:FireServer(target.Character.HumanoidRootPart.Position)
    -- end
end

--// Main Kill Aura Loop
spawn(function()
    while true do
        if enabled then
            local targets = getPlayersInRadius()
            for _, target in ipairs(targets) do
                attackTarget(target)
            end
        end
        wait(ATTACK_INTERVAL)
    end
end)

--// Keybind Toggle
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == ENABLE_KEY then
        enabled = not enabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Kill Aura",
            Text = enabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Rapid Fire",
   Callback = function()
        --// SETTINGS
local RAPID_FIRE_KEY = Enum.KeyCode.F        -- Key to toggle rapid fire
local FIRE_INTERVAL = 0.05                   -- Delay between shots (seconds); lower = faster

--// SERVICES
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// STATE
local rapidFireEnabled = false

--// Function: Simulate Firing
local function fireWeapon()
    -- For Tool-based guns
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("Activate") then
        tool:Activate()
    end

    -- For custom RemoteEvent-based guns (uncomment and customize as needed)
    -- local remote = tool and tool:FindFirstChild("RemoteNameHere")
    -- if remote then
    --     remote:FireServer()
    -- end
end

--// Rapid Fire Loop
task.spawn(function()
    while true do
        if rapidFireEnabled then
            fireWeapon()
            task.wait(FIRE_INTERVAL)
        else
            task.wait(0.1)
        end
    end
end)

--// Keybind Toggle
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == RAPID_FIRE_KEY then
        rapidFireEnabled = not rapidFireEnabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Rapid Fire",
            Text = rapidFireEnabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Dahood Resolver (T)",
   Callback = function()
        --// SETTINGS
local RESOLVER_KEY = Enum.KeyCode.T                -- Key to toggle resolver on/off
getgenv().Resolver_Enabled = false                 -- Start disabled; toggle with key
getgenv().Resolver_Part = "Head"       -- "Head" or "HumanoidRootPart"
getgenv().Resolver_Prediction = 0.13               -- Typical Da Hood prediction value

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

--// Toggle keybind
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == RESOLVER_KEY then
        getgenv().Resolver_Enabled = not getgenv().Resolver_Enabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Resolver",
            Text = getgenv().Resolver_Enabled and "ENABLED" or "DISABLED",
            Duration = 0.5
        })
    end
end)

--// Resolver function: Predicts real target position
local function resolveTarget(target)
    if not getgenv().Resolver_Enabled or not target or not target.Character then return nil end
    local part = target.Character:FindFirstChild(getgenv().Resolver_Part)
    if not part then return nil end
    local pos = part.Position
    local velocity = part.Velocity
    local predicted = pos + (velocity * getgenv().Resolver_Prediction)
    return predicted
end

--// Usage Example: Integrate with aimlock/silent aim targeting
local function getResolvedTarget()
    local closest, shortest = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(getgenv().Resolver_Part) and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local resolvedPos = resolveTarget(player) or player.Character[getgenv().Resolver_Part].Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(resolvedPos)
            if onScreen then
                local mouse = LocalPlayer:GetMouse()
                local dist = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < 90 and dist < shortest then -- 90 is a typical FOV
                    closest = player
                    shortest = dist
                end
            end
        end
    end
    return closest
end

--// To use: Replace your aimlock/silent aim target logic with getResolvedTarget() and resolveTarget(target)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Desync (B)",
   Callback = function()
       --// SETTINGS
local DESYNC_KEY = Enum.KeyCode.B         -- Key to toggle desync on/off
local DESYNC_SPEED = 20.5                  -- Desync movement speed (studs per tick)
local DESYNC_OFFSET = 50                  -- How far to offset your fake position (studs)

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

--// STATE
local desyncEnabled = false
local desyncDirection = 1

--// Toggle Keybind
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == DESYNC_KEY then
        desyncEnabled = not desyncEnabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Desync",
            Text = desyncEnabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)

--// Main Desync Loop
RunService.RenderStepped:Connect(function()
    if desyncEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        -- Rapidly offset your position back and forth to confuse aimlock/silent aim
        local offset = Vector3.new(DESYNC_OFFSET * desyncDirection, 0, 0)
        hrp.CFrame = hrp.CFrame + offset
        desyncDirection = -desyncDirection -- Flip direction for next frame
        -- Optionally, you can add a small random Y offset for more unpredictability
    end
end)

   end,
})

local Button =MainTab:CreateButton({
   Name = "Anti-Lock (U)",
   Callback = function()
        --// SETTINGS
local ANTILOCK_KEY = Enum.KeyCode.U         -- Key to toggle anti-lock on/off
getgenv().AntiLock_Enabled = false          -- Start disabled; toggle with key
getgenv().AntiLock_Amount = 90              -- How strong the anti-lock effect is (Y velocity)

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

--// Toggle Keybind
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == ANTILOCK_KEY then
        getgenv().AntiLock_Enabled = not getgenv().AntiLock_Enabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Anti-Lock",
            Text = getgenv().AntiLock_Enabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)

--// Anti-Lock Effect Loop
RunService.Heartbeat:Connect(function()
    if getgenv().AntiLock_Enabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        -- Temporarily set Y velocity very high, then restore
        local originalVel = hrp.Velocity
        hrp.Velocity = Vector3.new(0, getgenv().AntiLock_Amount, 0)
        RunService.RenderStepped:Wait()
        hrp.Velocity = originalVel
    end
end)

   end,
})

local MainSection = MainTab:CreateSection("Semi/Blatant")
local Button = MainTab:CreateButton({
   Name = "Hitbox Expander 2",
   Callback = function()
        game:GetService("StarterGui"):SetCore("SendNotification", {Title = "yeet", Text = "t = Enabled : p = disabled."})
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
 
-- Settings
 
bind = "" 
bind2 = "t"
bind3 = "p"
 
-- Script
 
mouse.KeyDown:connect(function(key)
if key == bind then
player.Character.HumanoidRootPart.CFrame = CFrame.new(1254.09656, 137.906067, -172.128204)
end
end)
 
mouse.KeyDown:connect(function(key2)
if key2 == bind2 then
_G.HeadSize = 7
_G.Disabled = true
 
 
if _G.Disabled then
for i,v in next, game:GetService('Players'):GetPlayers() do
if v.Name ~= game:GetService('Players').LocalPlayer.Name then
pcall(function()
v.Character.HumanoidRootPart.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize)
v.Character.HumanoidRootPart.Transparency = 0.7
v.Character.HumanoidRootPart.BrickColor = BrickColor.new("Really blue")
v.Character.HumanoidRootPart.Material = "Neon"
v.Character.HumanoidRootPart.CanCollide = false
end)
end
end
end
end
end)
 
mouse.KeyDown:connect(function(key3)
if key3 == bind3 then
_G.HeadSize = 7
_G.Disabled = true
 
 
for i,v in next, game:GetService('Players'):GetPlayers() do
if v.Name ~= game:GetService('Players').LocalPlayer.Name then
pcall(function()
v.Character.HumanoidRootPart.Size = Vector3.new(16, 16, 16)
v.Character.HumanoidRootPart.Transparency = 1
v.Character.HumanoidRootPart.BrickColor = BrickColor.new("Medium stone grey")
v.Character.HumanoidRootPart.Material = "Plastic"
v.Character.HumanoidRootPart.CanCollide = true
end)
end
end
end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Triggerbot (c) [Don't Work On Dahood I Think]",
   Callback = function()
        getgenv().yen = {
    triggerbot = {
        settings = {
            enabled = true,
            keybind = "C",
            notifications = true,
            delay = 0.035
        },
        prediction = {
            settings = {
                amount = 9, -- use 6.5-10 (prediction)
                radius = 25 -- basically hitbox size for prediction
            }
        },
        fov = {
            enabled = true,
            size = 8
        }
    },
    info = {
        safe_mode = true, 
        version = "1.0" -- still in beta
    }
}

-- by dashy, use with silent aim / aim assist

loadstring(game:HttpGet("https://raw.githubusercontent.com/dashy2202/utilities/main/triggerbot-v1"))()
   end,
})

local Button = MainTab:CreateButton({
   Name = "Semi Legit Camlock (c)",
   Callback = function()
       getgenv().RecurringPoint = "UpperTorso"
getgenv().Hitbox = "UpperTorso"
getgenv().Keybind = "c"
getgenv().AimbotStrengthAmount = 0.3823
getgenv().PredictionAmount = 6.75
getgenv().Radius = 36
getgenv().UsePrediction = true
getgenv().AimbotStrength = true
getgenv().FirstPerson = true
getgenv().ThirdPerson = true
getgenv().TeamCheck = false
getgenv().Enabled = true


-- // main script use with silent aim / / -- 

loadstring(game:HttpGet("https://raw.githubusercontent.com/tenaaki/GenericAimbot/main/v1.0.0"))()
   end,
})

local Button = MainTab:CreateButton({
   Name = "Hitbox Expander (kinda buggy)",
   Callback = function()
local size = 12

local Players = cloneref(game:GetService("Players"))
local RS = cloneref(game:GetService("RunService"))
local Client = Players.LocalPlayer
RS.RenderStepped:Connect(function ()
    for _, Player in pairs(Players:GetPlayers()) do
        if Player == Client then continue end
        local HRP = Player.Character:WaitForChild("HumanoidRootPart")
        HRP.Size = Vector3.new(size, size, size)
        HRP.Transparency = 0.5
    end
end)

   end,
})

local MainSection = MainTab:CreateSection("Camlocks/Triggerbots")

local Button = MainTab:CreateButton({
   Name = "Camlock (c)",
   Callback = function()
        -- === EDITABLE SETTINGS ===
getgenv().Aimbot = {
    Status = true,
    Keybind = 'C',
    Hitpart = 'UpperTorso',
    Smoothness = 0.15, -- Lower = snappier, Higher = smoother (0.01 to 1 recommended)
    Prediction = {
        X = 0.165,     -- Increase if targets move fast, decrease if too much lead
        Y = 0.1,
    },
}
-- =========================

if getgenv().AimbotRan then
    -- Allow re-execution to update settings
    if getgenv().AimbotDisconnects then
        for _, conn in ipairs(getgenv().AimbotDisconnects) do
            pcall(function() conn:Disconnect() end)
        end
    end
else
    getgenv().AimbotRan = true
end
getgenv().AimbotDisconnects = {}

local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local Player = nil

local function GetClosestPlayer()
    local ClosestDistance, ClosestPlayer = 100000, nil
    for _, PlayerObj in pairs(Players:GetPlayers()) do
        if PlayerObj.Name ~= LocalPlayer.Name and PlayerObj.Character and PlayerObj.Character:FindFirstChild('HumanoidRootPart') then
            local Root, Visible = Camera:WorldToScreenPoint(PlayerObj.Character.HumanoidRootPart.Position)
            if not Visible then continue end
            Root = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(Root.X, Root.Y)).Magnitude
            if Root < ClosestDistance then
                ClosestPlayer = PlayerObj
                ClosestDistance = Root
            end
        end
    end
    return ClosestPlayer
end

table.insert(getgenv().AimbotDisconnects, Mouse.KeyDown:Connect(function(key)
    if key == Aimbot.Keybind:lower() then
        Player = not Player and GetClosestPlayer() or nil
    end
end))

table.insert(getgenv().AimbotDisconnects, RunService.RenderStepped:Connect(function()
    if not Player or not Aimbot.Status then return end
    local Hitpart = Player.Character and Player.Character:FindFirstChild(Aimbot.Hitpart)
    if not Hitpart then return end

    local predictedPos = Hitpart.Position + Hitpart.Velocity * Vector3.new(Aimbot.Prediction.X, Aimbot.Prediction.Y, Aimbot.Prediction.X)
    local current = Camera.CFrame.Position
    local smoothness = math.clamp(Aimbot.Smoothness, 0.01, 1)
    local newLook = current:Lerp(predictedPos, smoothness)
    Camera.CFrame = CFrame.new(current, newLook)
end))

   end,
})

local Button = MainTab:CreateButton({
   Name = "Camlock (has sliders)",
   Callback = function()
        -- SETTINGS (will be updated live by sliders/keypicker)
getgenv().Aimlock = getgenv().Aimlock or {
    Enabled = true,
    Keybind = 'C', -- Default, can be changed by KeyPicker
    Hitpart = 'UpperTorso',
    Prediction = 0.16, -- ca  be changed by predictionSlider
    FOV = 120, -- can be changed by FovSlider
    Smoothness = 0.13, -- can be changed by SmoothnessSlider
}

-- Disconnect previous connections for re-execution
if getgenv().AimlockDisconnects then
    for _, conn in ipairs(getgenv().AimlockDisconnects) do
        pcall(function() conn:Disconnect() end)
    end
end
getgenv().AimlockDisconnects = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local LockedPlayer = nil

-- Get closest player in FOV
local function GetClosestPlayer()
    local closest, closestDist = nil, getgenv().Aimlock.FOV
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild(getgenv().Aimlock.Hitpart) then
            local pos, onscreen = Camera:WorldToViewportPoint(plr.Character[getgenv().Aimlock.Hitpart].Position)
            if onscreen then
                local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
                if dist < closestDist then
                    closest = plr
                    closestDist = dist
                end
            end
        end
    end
    return closest
end

-- Keybind to lock/unlock (now uses UserInputService for any key)
table.insert(getgenv().AimlockDisconnects, UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    local key = input.KeyCode.Name:lower()
    if key == tostring(getgenv().Aimlock.Keybind):lower() then
        LockedPlayer = not LockedPlayer and GetClosestPlayer() or nil
    end
end))

-- Main aimlock logic
table.insert(getgenv().AimlockDisconnects, RunService.RenderStepped:Connect(function()
    if not getgenv().Aimlock.Enabled or not LockedPlayer or not LockedPlayer.Character then return end
    local part = LockedPlayer.Character:FindFirstChild(getgenv().Aimlock.Hitpart)
    if not part then return end
    local predicted = part.Position + (part.Velocity * getgenv().Aimlock.Prediction)
    local current = Camera.CFrame.Position
    local smoothness = math.clamp(getgenv().Aimlock.Smoothness, 0.01, 1)
    local newLook = current:Lerp(predicted, smoothness)
    Camera.CFrame = CFrame.new(current, newLook)
end))

-- === RAYFIELD SLIDERS ===
MainTab:CreateSlider({
    Name = "Prediction",
    Range = {0, 0.5},
    Increment = 0.005,
    Suffix = "",
    CurrentValue = getgenv().Aimlock.Prediction,
    Flag = "PredictionSlider",
    Callback = function(Value)
        getgenv().Aimlock.Prediction = Value
    end,
})

MainTab:CreateSlider({
    Name = "FOV",
    Range = {20, 500},
    Increment = 1,
    Suffix = "px",
    CurrentValue = getgenv().Aimlock.FOV,
    Flag = "FOVSlider",
    Callback = function(Value)
        getgenv().Aimlock.FOV = Value
    end,
})

MainTab:CreateSlider({
    Name = "Smoothness",
    Range = {0.01, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = getgenv().Aimlock.Smoothness,
    Flag = "SmoothnessSlider",
    Callback = function(Value)
        getgenv().Aimlock.Smoothness = Value
    end,
})

-- === RAYFIELD KEYBIND PICKER ===
MainTab:CreateKeybind({
    Name = "Aimlock Keybind",
    CurrentKeybind = getgenv().Aimlock.Keybind,
    Flag = "AimlockKeybind",
    Callback = function(Key)
        -- Key will be Enum.KeyCode, convert to string for comparison
        if typeof(Key) == "EnumItem" then
            getgenv().Aimlock.Keybind = Key.Name
        elseif typeof(Key) == "string" then
            getgenv().Aimlock.Keybind = Key
        end
    end,
})

-- OPTIONAL: FOV Circle (visual, not required for aimlock to work)
local Drawing = Drawing or nil
if Drawing then
    if getgenv().AimlockFOVCircle then getgenv().AimlockFOVCircle:Remove() end
    local circle = Drawing.new("Circle")
    getgenv().AimlockFOVCircle = circle
    circle.Color = Color3.fromRGB(0, 170, 255)
    circle.Thickness = 2
    circle.Filled = false
    circle.Transparency = 0.6
    circle.Visible = true
    RunService.RenderStepped:Connect(function()
        circle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        circle.Radius = getgenv().Aimlock.FOV
        circle.Visible = getgenv().Aimlock.Enabled
    end)
end

    end,
})

local MainSection = MainTab:CreateSection("Silent/More")

local Button = MainTab:CreateButton({
   Name = "No-Recoil",
   Callback = function()
        -- Universal No Recoil Script for Da Hood & Copies

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Function to remove recoil from all tools in backpack and character
local function removeRecoil(tool)
    if tool and tool:IsA("Tool") then
        for _, obj in ipairs(tool:GetDescendants()) do
            if obj:IsA("NumberValue") and obj.Name:lower():find("recoil") then
                obj.Value = 0
            end
            if obj:IsA("ModuleScript") and obj.Name:lower():find("gun") then
                local success, gunModule = pcall(require, obj)
                if success and type(gunModule) == "table" then
                    for k, v in pairs(gunModule) do
                        if tostring(k):lower():find("recoil") and type(v) == "number" then
                            gunModule[k] = 0
                        end
                    end
                end
            end
        end
    end
end

-- Loop through all tools and remove recoil
local function loopNoRecoil()
    -- Check backpack
    for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
        removeRecoil(tool)
    end
    -- Check equipped tools
    if LocalPlayer.Character then
        for _, tool in ipairs(LocalPlayer.Character:GetChildren()) do
            removeRecoil(tool)
        end
    end
end

-- Run on script start and every time you equip or get a new tool
loopNoRecoil()
LocalPlayer.Backpack.ChildAdded:Connect(loopNoRecoil)
if LocalPlayer.Character then
    LocalPlayer.Character.ChildAdded:Connect(loopNoRecoil)
end
LocalPlayer.CharacterAdded:Connect(function(char)
    char.ChildAdded:Connect(loopNoRecoil)
    loopNoRecoil()
end)

-- Optionally, run in a loop to catch any changes
while true do
    loopNoRecoil()
    task.wait(2)
end

print("No Recoil script loaded!")

   end,
})

local Button = MainTab:CreateButton({
   Name = "Streamable Hitbox Expander",
   Callback = function()
        -- Streamable Hitbox Expander for Da Hood & Copies

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- === CONFIGURATION ===
local SIZE = Vector3.new(7, 7, 7) -- Default HRP is about 2,2,1; this is much larger
local TRANSPARENCY = 0.9 -- Nearly invisible (1 = fully invisible, 0 = fully visible)
local COLOR = Color3.fromRGB(255, 0, 0) -- Only you see this, for debugging
-- =====================

local function expandHitbox(char)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp and hrp.ClassName == "Part" then
        hrp.Size = SIZE
        hrp.Transparency = TRANSPARENCY
        hrp.Color = COLOR
        hrp.Material = Enum.Material.ForceField
        hrp.CanCollide = false
    end
end

-- Initial application to all players
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer and player.Character then
        expandHitbox(player.Character)
    end
end

-- Apply to new players and respawns
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        expandHitbox(char)
    end)
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            task.wait(0.5)
            expandHitbox(char)
        end)
    end
end

print("Streamable Hitbox Expander loaded! Only you see the expanded hitboxes.")

   end,
})

local MainTab = Window:CreateTab("🏃‍♀️Movement", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")

local Button = MainTab:CreateButton({
   Name = "Cframe Speed (x)",
   Callback = function()
        --// SETTINGS
local SPEED = 2.5                -- Adjust for desired speed (higher = faster, 2.5–4 is typical)
local TOGGLE_KEY = Enum.KeyCode.X -- Key to toggle CFrame speed on/off

--// SERVICES
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// STATE
local cframeSpeedEnabled = false

--// Main CFrame Speed Loop
RunService.RenderStepped:Connect(function()
    if cframeSpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        local moveVec = Vector3.new(0, 0, 0)
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + (workspace.CurrentCamera.CFrame.LookVector) end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec - (workspace.CurrentCamera.CFrame.LookVector) end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec - (workspace.CurrentCamera.CFrame.RightVector) end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + (workspace.CurrentCamera.CFrame.RightVector) end
        if moveVec.Magnitude > 0 then
            hrp.CFrame = hrp.CFrame + (moveVec.Unit * SPEED)
        end
    end
end)

--// Toggle Keybind
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == TOGGLE_KEY then
        cframeSpeedEnabled = not cframeSpeedEnabled
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "CFrame Speed",
            Text = cframeSpeedEnabled and "ENABLED" or "DISABLED",
            Duration = 1
        })
    end
end)

   end,
})

local Slider = MainTab:CreateSlider({
   Name = "WalkSpeed",
   Range = {16, 300},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(v)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = v
   end,
})

local Slider = MainTab:CreateSlider({
   Name = "JumpPower",
   Range = {50, 500},
   Increment = 10,
   Suffix = "JumpPower",
   CurrentValue = 50,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(v)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = v
   end,
})

local Button = MainTab:CreateButton({
   Name = "Fly(X)",
   Callback = function()
    local plr = game.Players.LocalPlayer
local mouse = plr:GetMouse()

localplayer = plr

if workspace:FindFirstChild("Core") then
workspace.Core:Destroy()
end

local Core = Instance.new("Part")
Core.Name = "Core"
Core.Size = Vector3.new(0.05, 0.05, 0.05)

spawn(function()
Core.Parent = workspace
local Weld = Instance.new("Weld", Core)
Weld.Part0 = Core
Weld.Part1 = localplayer.Character.LowerTorso
Weld.C0 = CFrame.new(0, 0, 0)
end)

workspace:WaitForChild("Core")

local torso = workspace.Core
flying = true
local speed=10
local keys={a=false,d=false,w=false,s=false}
local e1
local e2
local function start()
local pos = Instance.new("BodyPosition",torso)
local gyro = Instance.new("BodyGyro",torso)
pos.Name="EPIXPOS"
pos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
pos.position = torso.Position
gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
gyro.cframe = torso.CFrame
repeat
wait()
localplayer.Character.Humanoid.PlatformStand=true
local new=gyro.cframe - gyro.cframe.p + pos.position
if not keys.w and not keys.s and not keys.a and not keys.d then
speed=5
end
if keys.w then
new = new + workspace.CurrentCamera.CoordinateFrame.lookVector * speed
speed=speed+0
end
if keys.s then
new = new - workspace.CurrentCamera.CoordinateFrame.lookVector * speed
speed=speed+0
end
if keys.d then
new = new * CFrame.new(speed,0,0)
speed=speed+0
end
if keys.a then
new = new * CFrame.new(-speed,0,0)
speed=speed+0
end
if speed>10 then
speed=5
end
pos.position=new.p
if keys.w then
gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(-math.rad(speed*0),0,0)
elseif keys.s then
gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(math.rad(speed*0),0,0)
else
gyro.cframe = workspace.CurrentCamera.CoordinateFrame
end
until flying == false
if gyro then gyro:Destroy() end
if pos then pos:Destroy() end
flying=false
localplayer.Character.Humanoid.PlatformStand=false
speed=10
end
e1=mouse.KeyDown:connect(function(key)
if not torso or not torso.Parent then flying=false e1:disconnect() e2:disconnect() return end
if key=="w" then
keys.w=true
elseif key=="s" then
keys.s=true
elseif key=="a" then
keys.a=true
elseif key=="d" then
keys.d=true
elseif key=="x" then
if flying==true then
flying=false
else
flying=true
start()
end
end
end)
e2=mouse.KeyUp:connect(function(key)
if key=="w" then
keys.w=false
elseif key=="s" then
keys.s=false
elseif key=="a" then
keys.a=false
elseif key=="d" then
keys.d=false
end
end)
end,
})

local MainTab = Window:CreateTab("🎲Misc", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")

local Button = MainTab:CreateButton({
   Name = "SpyChat",
   Callback = function()
        enabled = true --chat "/spy" to toggle!
spyOnMyself = true --if true will check your messages too
public = false --if true will chat the logs publicly (fun, risky)
publicItalics = true --if true will use /me to stand out
privateProperties = { --customize private logs
    Color = Color3.fromRGB(0,255,255); 
    Font = Enum.Font.SourceSansBold;
    TextSize = 18;
}
 
 
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local player = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() or Players.LocalPlayer
local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
local instance = (_G.chatSpyInstance or 0) + 1
_G.chatSpyInstance = instance
 
local function onChatted(p,msg)
    if _G.chatSpyInstance == instance then
        if p==player and msg:lower():sub(1,4)=="/spy" then
            enabled = not enabled
            wait(0.3)
            privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
            StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
        elseif enabled and (spyOnMyself==true or p~=player) then
            msg = msg:gsub("[\n\r]",''):gsub("\t",' '):gsub("[ ]+",' ')
            local hidden = true
            local conn = getmsg.OnClientEvent:Connect(function(packet,channel)
                if packet.SpeakerUserId==p.UserId and packet.Message==msg:sub(#msg-#packet.Message+1) and (channel=="All" or (channel=="Team" and public==false and Players[packet.FromSpeaker].Team==player.Team)) then
                    hidden = false
                end
            end)
            wait(1)
            conn:Disconnect()
            if hidden and enabled then
                if public then
                    saymsg:FireServer((publicItalics and "/me " or '').."{SPY} [".. p.Name .."]: "..msg,"All")
                else
                    privateProperties.Text = "{SPY} [".. p.Name .."]: "..msg
                    StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
                end
            end
        end
    end
end
 
for _,p in ipairs(Players:GetPlayers()) do
    p.Chatted:Connect(function(msg) onChatted(p,msg) end)
end
Players.PlayerAdded:Connect(function(p)
    p.Chatted:Connect(function(msg) onChatted(p,msg) end)
end)
privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
if not player.PlayerGui:FindFirstChild("Chat") then wait(3) end
local chatFrame = player.PlayerGui.Chat.Frame
chatFrame.ChatChannelParentFrame.Visible = true
chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
   end,
})

local Button = MainTab:CreateButton({
   Name = "Animation Pack (tryhard)",
   Callback = function()
       while true do
local Animate = game.Players.LocalPlayer.Character.Animate
Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=782841498"
Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=782841498"
Animate.walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=616168032"
Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=1083218792"
Animate.climb.ClimbAnim.AnimationId = "http://www.roblox.com/asset/?id=1083439238"
Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
game.Players.LocalPlayer.Character.Humanoid.Jump = false
wait(1)
end
   end,
})

local Button = MainTab:CreateButton({
   Name = "Auto-Reload",
   Callback = function()
_G.AutoReload = true -- change to false if u don't want it anymore.

while _G.AutoReload == true and game:GetService("RunService").Heartbeat:Wait() do
if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
            if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo") then
                if game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo").Value <= 0 then
                    game:GetService("ReplicatedStorage").MainEvent:FireServer("Reload", game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool")) 
                    wait(1)
                end
            end
        end
end
   end,
})

local Button = MainTab:CreateButton({
   Name = "Aura Heal",
   Callback = function()
local Players = game:GetService("Players")

local HitEffectModule = {
    Locals = {
        HitEffect = {
            Type = {}
        }
    }
}

local Attachment = Instance.new("Attachment")
HitEffectModule.Locals.HitEffect.Type["Skibidi RedRizz"] = Attachment

local MainColor = Color3.fromRGB(255, 255, 253)

local HealingWave1 = Instance.new("ParticleEmitter")
HealingWave1.Name = "Healing Wave 1"
HealingWave1.Lifetime = NumberRange.new(1.5, 1.5)
HealingWave1.SpreadAngle = Vector2.new(10, -10)
HealingWave1.LockedToPart = true
HealingWave1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1702454, 0.7, 0.014881), NumberSequenceKeypoint.new(0.2254601, 0.03125, 0.03125), NumberSequenceKeypoint.new(0.2852761, 0), NumberSequenceKeypoint.new(0.702454, 0), NumberSequenceKeypoint.new(0.8374233, 0.9125, 0.0601461), NumberSequenceKeypoint.new(1, 1)})
HealingWave1.LightEmission = 0.4
HealingWave1.Color = ColorSequence.new(Color3.fromRGB(234, 8, 255))
HealingWave1.VelocitySpread = 10
HealingWave1.Speed = NumberRange.new(3, 6)
HealingWave1.Brightness = 10
HealingWave1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 3.0624998, 1.8805969), NumberSequenceKeypoint.new(0.6420546, 1.9999999, 1.7619393), NumberSequenceKeypoint.new(1, 0.7499999, 0.7499999)})
HealingWave1.Rate = 20
HealingWave1.Texture = "rbxassetid://8047533775"
HealingWave1.RotSpeed = NumberRange.new(200, 400)
HealingWave1.Rotation = NumberRange.new(-180, 180)
HealingWave1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
HealingWave1.Parent = Attachment

local HealingWave2 = Instance.new("ParticleEmitter")
HealingWave2.Name = "Healing Wave 2"
HealingWave2.Lifetime = NumberRange.new(1.5, 1.5)
HealingWave2.SpreadAngle = Vector2.new(10, -10)
HealingWave2.LockedToPart = true
HealingWave2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.2254601, 0.03125, 0.03125), NumberSequenceKeypoint.new(0.6288344, 0.25625, 0.0593491), NumberSequenceKeypoint.new(0.8374233, 0.9125, 0.0601461), NumberSequenceKeypoint.new(1, 1)})
HealingWave2.LightEmission = 1
HealingWave2.Color = ColorSequence.new(Color3.fromRGB(238, 3, 255))
HealingWave2.VelocitySpread = 10
HealingWave2.Speed = NumberRange.new(3, 5)
HealingWave2.Brightness = 10
HealingWave2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 3.125), NumberSequenceKeypoint.new(0.4165329, 1.3749999, 1.3749999), NumberSequenceKeypoint.new(1, 0.9375, 0.9375)})
HealingWave2.Rate = 20
HealingWave2.Texture = "rbxassetid://8047796070"
HealingWave2.RotSpeed = NumberRange.new(100, 300)
HealingWave2.Rotation = NumberRange.new(-180, 180)
HealingWave2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
HealingWave2.Parent = Attachment

local Sparks = Instance.new("ParticleEmitter")
Sparks.Name = "Sparks"
Sparks.Lifetime = NumberRange.new(0.5, 2)
Sparks.SpreadAngle = Vector2.new(180, -180)
Sparks.LightEmission = 1
Sparks.Color = ColorSequence.new(Color3.fromRGB(255, 21, 255))
Sparks.Drag = 3
Sparks.VelocitySpread = 180
Sparks.Speed = NumberRange.new(5, 15)
Sparks.Brightness = 10
Sparks.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.14687, 0.4374999, 0.1875001), NumberSequenceKeypoint.new(1, 0)})
Sparks.Acceleration = Vector3.new(0, 3, 0)
Sparks.ZOffset = -1
Sparks.Rate = 40
Sparks.Texture = "rbxassetid://8611887361"
Sparks.RotSpeed = NumberRange.new(-30, 30)
Sparks.Orientation = Enum.ParticleOrientation.VelocityParallel
Sparks.Parent = Attachment

local StarSparks = Instance.new("ParticleEmitter")
StarSparks.Name = "Star Sparks"
StarSparks.Lifetime = NumberRange.new(1.5, 1.5)
StarSparks.SpreadAngle = Vector2.new(180, -180)
StarSparks.LightEmission = 1
StarSparks.Color = ColorSequence.new(Color3.fromRGB(226, 60, 255))
StarSparks.Drag = 3
StarSparks.VelocitySpread = 180
StarSparks.Speed = NumberRange.new(5, 10)
StarSparks.Brightness = 10
StarSparks.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.1492777, 0.6874996, 0.6874996), NumberSequenceKeypoint.new(1, 0)})
StarSparks.Acceleration = Vector3.new(0, 3, 0)
StarSparks.ZOffset = 2
StarSparks.Texture = "rbxassetid://8611887703"
StarSparks.RotSpeed = NumberRange.new(-30, 30)
StarSparks.Rotation = NumberRange.new(-30, 30)
StarSparks.Parent = Attachment

local function spawn()
    local player = Players.LocalPlayer

    Attachment.Parent = player.Character.LowerTorso

    StarSparks.Enabled = true
    Sparks.Enabled = true
    HealingWave1.Enabled = true
    HealingWave2.Enabled = true
end

spawn()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Stretched Resolution",
   Callback = function()
        getgenv().Resolution = {
    [".gg/scripters"] = 0.65
}

local Camera = workspace.CurrentCamera
if getgenv().gg_scripters == nil then
    game:GetService("RunService").RenderStepped:Connect(
        function()
            Camera.CFrame = Camera.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, getgenv().Resolution[".gg/scripters"], 0, 0, 0, 1)
        end
    )
end
getgenv().gg_scripters = "Aori0001"
   end,
})

local Button = MainTab:CreateButton({
   Name = "No Jump CoolDown",
   Callback = function()
        local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local function getHumanoid()
    local character = LocalPlayer.Character
    if character and character:FindFirstChildOfClass("Humanoid") then
        return character:FindFirstChildOfClass("Humanoid")
    end
end


RunService.Heartbeat:Connect(function()
    local humanoid = getHumanoid()
    if humanoid then
        humanoid.UseJumpPower = false
    end
end) 

   end,
})

local Button = MainTab:CreateButton({
   Name = "Spin-Bot (t)",
   Callback = function()
       local speed = 450

local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local isToggled = false

game:GetService("UserInputService").InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.T then
        isToggled = not isToggled
    end
end)

RunService.RenderStepped:Connect(function(Delta)
    if isToggled then
        LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad((speed)) * Delta, 0)
        LocalPlayer.Character:FindFirstChild("Humanoid").AutoRotate = false
    else
        LocalPlayer.Character:FindFirstChild("Humanoid").AutoRotate = true
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Dahood Emote Animations (Idk If Work For Now)",
   Callback = function()
        --// SETTINGS: Animation IDs (from Da Hood)
local Animations = {
    Lean = "3152375249",
    Greet = "3189773368",
    Lay = "3236836673",
    Dance1 = "3189773368",   -- Replace with actual dance IDs if needed
    Dance2 = "3189776546",
    Dance3 = "3189778125"
}

--// SERVICES
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

--// Helper: Play Animation
local function playAnimation(animId)
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- Stop previous animation
        if humanoid:FindFirstChild("Animator") then
            for _, track in ipairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                track:Stop()
            end
        end
        -- Play new animation
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. animId
        local track = humanoid:LoadAnimation(anim)
        track:Play()
    end
end

--// Chat Command Handler
LocalPlayer.Chatted:Connect(function(msg)
    msg = msg:lower()
    if msg == "/e lean" then
        playAnimation(Animations.Lean)
    elseif msg == "/e greet" then
        playAnimation(Animations.Greet)
    elseif msg == "/e lay" then
        playAnimation(Animations.Lay)
    elseif msg == "/e dance1" then
        playAnimation(Animations.Dance1)
    elseif msg == "/e dance2" then
        playAnimation(Animations.Dance2)
    elseif msg == "/e dance3" then
        playAnimation(Animations.Dance3)
    end
end)

--// Optional: Keybinds for quick access (change as desired)
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Z then
        playAnimation(Animations.Lean)
    elseif input.KeyCode == Enum.KeyCode.X then
        playAnimation(Animations.Greet)
    elseif input.KeyCode == Enum.KeyCode.C then
        playAnimation(Animations.Lay)
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Anti Fling",
   Callback = function()
       local localPlayer = game:GetService('Players').LocalPlayer;
                local localCharacter = localPlayer.Character;
                localCharacter:FindFirstChildOfClass('Humanoid').Health = 0;
                local newCharacter = localPlayer.CharacterAdded:Wait();
                local spoofFolder = Instance.new('Folder');
                spoofFolder.Name = 'FULLY_LOADED_CHAR';
                spoofFolder.Parent = newCharacter;
                newCharacter:WaitForChild('RagdollConstraints'):Destroy();
                local spoofValue = Instance.new('BoolValue', newCharacter);
                spoofValue.Name = 'RagdollConstraints';
                local name = game.Players.LocalPlayer.Name
                local lol =    game.Workspace:WaitForChild(name)
                local money = Instance.new("Folder",game.Players.LocalPlayer.Character);money.Name = "FULLY_LOADED_CHAR"
                lol.Parent = game.Workspace.Players
                game.Players.LocalPlayer.Character:WaitForChild("BodyEffects")
                game.Players.LocalPlayer.Character.BodyEffects.BreakingParts:Destroy()
   end,
})

local Button = MainTab:CreateButton({
   Name = "Fist-Reach",
   Callback = function()
       LP = game.Players.LocalPlayer
for i,v in ipairs(LP.Character:GetDescendants()) do
if v:IsA("MeshPart") then v.Massless = true
v.CanCollide = false
v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

end
end

for i,v in ipairs(game.workspace:GetDescendants()) do
if v:IsA("Seat") then 
v.Disabled = true
end
end
x = 35
y = 35
z = 35


penis = Vector3.new(x,y,z)

LP.Character.RightHand.Size = penis

LP.Character.RightHand.Transparency = 1
local selectionBox = Instance.new("SelectionBox",LP.Character.RightHand)
selectionBox.Adornee = LP.Character.RightHand
selectionBox.Color3 = Color3.new(1,0,0)

LP.Character.LeftHand.Size = penis
LP.Character.BodyEffects.SpecialParts.LeftHand.Size = penis

LP.Character.LeftHand.Transparency = 1
local selectionBox = Instance.new("SelectionBox",LP.Character.LeftHand)
selectionBox.Adornee = LP.Character.LeftHand
selectionBox.Color3 = Color3.new(1,0,0)
   end,
})

local Button = MainTab:CreateButton({
   Name = "Fps boost (Makes Everything Low Quality And Makes It laggy For A While But After Like 1Min Then Its Good)",
   Callback = function()
        -- Made by RIP#6666
_G.Settings = {
    Players = {
        ["Ignore Me"] = true, -- Ignore your Character
        ["Ignore Others"] = true -- Ignore other Characters
    },
    Meshes = {
        Destroy = false, -- Destroy Meshes
        LowDetail = true -- Low detail meshes (NOT SURE IT DOES ANYTHING)
    },
    Images = {
        Invisible = true, -- Invisible Images
        LowDetail = false, -- Low detail images (NOT SURE IT DOES ANYTHING)
        Destroy = false, -- Destroy Images
    },
    ["No Particles"] = true, -- Disables all ParticleEmitter, Trail, Smoke, Fire and Sparkles
    ["No Camera Effects"] = true, -- Disables all PostEffect's (Camera/Lighting Effects)
    ["No Explosions"] = true, -- Makes Explosion's invisible
    ["No Clothes"] = true, -- Removes Clothing from the game
    ["Low Water Graphics"] = true, -- Removes Water Quality
    ["No Shadows"] = true, -- Remove Shadows
    ["Low Rendering"] = true, -- Lower Rendering
    ["Low Quality Parts"] = true -- Lower quality parts
}
loadstring(game:HttpGet("https://raw.githubusercontent.com/CasperFlyModz/discord.gg-rips/main/FPSBooster.lua"))()
   end,
})

local MainSection = MainTab:CreateSection("ATM Cash Farm")

local Button = MainTab:CreateButton({
   Name = "ATM CASH FARM (PRESS ONCE)",
   Callback = function()
        -- Da Hood ATM Cash Farm Script (No loadstrings, fully open source)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Find all ATM objects in the workspace
local function getATMs()
    local atms = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj.Name:lower():find("atm") and obj:IsA("BasePart") then
            table.insert(atms, obj)
        end
    end
    return atms
end

-- Teleport to ATM position
local function tpToATM(atm)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = atm.CFrame + Vector3.new(0, 3, 0)
    end
end

-- Simulate punch (equip fist or melee tool and activate)
local function punchATM()
    local char = LocalPlayer.Character
    if not char then return end
    local tool = char:FindFirstChildOfClass("Tool") or LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
    if tool then
        tool.Parent = char
        tool:Activate()
    else
        -- Try to punch with fists by jumping (as a fallback)
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end

-- Main autofarm loop
while true do
    local atms = getATMs()
    for _, atm in ipairs(atms) do
        if atm and atm.Parent then
            tpToATM(atm)
            -- Punch until ATM is broken or timeout
            local startTime = tick()
            while atm.Parent and (tick() - startTime < 8) do
                punchATM()
                task.wait(0.18)
            end
            task.wait(0.5)
        end
    end
    -- Wait for ATMs to respawn
    task.wait(15)
end

   end,
})

local MainSection = MainTab:CreateSection("Other")

local Button = MainTab:CreateButton({
   Name = "Auto Stomp",
   Callback = function()
        -- Da Hood Auto Stomp on Walk-Over Script (Client-Sided, No loadstrings)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Function to check if a player is knocked
local function isKnocked(player)
    if player and player.Character and player.Character:FindFirstChild("Humanoid") then
        local hum = player.Character.Humanoid
        -- In Da Hood, knocked players usually have Health < 10 and PlatformStand = true
        return hum.Health > 0 and hum.Health < 10 and hum.PlatformStand
    end
    return false
end

-- Function to check if you are standing over a knocked player
local function isOverKnockedPlayer(knockedChar)
    local myChar = LocalPlayer.Character
    if not myChar or not knockedChar then return false end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    local knockedRoot = knockedChar:FindFirstChild("HumanoidRootPart")
    if myRoot and knockedRoot then
        local dist = (myRoot.Position - knockedRoot.Position).Magnitude
        return dist < 5 -- 5 studs is a good "walk-over" radius
    end
    return false
end

-- Function to stomp (simulate pressing 'E')
local function stomp()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

-- Main loop
while true do
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and isKnocked(player) then
            if isOverKnockedPlayer(player.Character) then
                stomp()
                task.wait(0.6) -- Wait to avoid double-stomping
            end
        end
    end
    task.wait(0.1)
end

    end,
})

local Button = MainTab:CreateButton({
   Name = "Auto Armour",
   Callback = function()
        -- Da Hood Auto-Armor When Armor Is Popped Script

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Change this to the armor you want ("Body Armor" or "Heavy Armor")
local desiredArmor = "Body Armor"

-- Shop locations for armor (update these if Da Hood map changes)
local armorShops = {
    ["Body Armor"] = Vector3.new(-224, 22, -176),
    ["Heavy Armor"] = Vector3.new(-265, 22, -176)
}

-- Function to check if you have armor equipped
local function hasArmor()
    local char = LocalPlayer.Character
    if not char then return false end
    -- Armor is usually a "BodyEffects" child named "Armor"
    local bodyEffects = char:FindFirstChild("BodyEffects")
    if bodyEffects and bodyEffects:FindFirstChild("Armor") then
        return bodyEffects.Armor.Value > 0
    end
    return false
end

-- Function to teleport to armor shop
local function tpTo(pos)
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if root then
        root.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
    end
end

-- Function to buy armor (fires proximity prompt)
local function buyArmor()
    local shopPos = armorShops[desiredArmor]
    if not shopPos then return end
    tpTo(shopPos)
    task.wait(0.4)
    -- Try to fire ProximityPrompt or interact with the armor shop
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") and obj.Parent and obj.Parent.Name == desiredArmor then
            fireproximityprompt(obj)
            break
        end
    end
end

-- Main loop: Monitor armor and auto-buy if popped
while true do
    if not hasArmor() then
        buyArmor()
        -- Wait a bit to avoid spamming
        task.wait(2)
    end
    task.wait(0.5)
end

   end,
})

local MainTab = Window:CreateTab("🌐 World", nil) -- Title, Image
local MainSection = MainTab:CreateSection("ESP")

local Button = MainTab:CreateButton({
   Name = "Esp (kinda laggy)",
   Callback = function()
       -- Simple player highlighting and nametag script with toggle feature now
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local MaxDistance = 400.5 -- Range in studs for nametags to show
 
-- Toggle variable
local NametagsEnabled = true 
 
-- Function to create a nametag for a player
local function CreateNametag(Player)
    if Player == LocalPlayer then return end -- Skip local player
 
    local function SetupNametag(Character)
        local Head = Character:FindFirstChild("Head")
        if not Head then return end -- If no head, exit
 
        -- Remove existing nametag if it exists
        local OldNametag = Head:FindFirstChild("Nametag")
        if OldNametag then
            OldNametag:Destroy()
        end
 
        local BillboardGui = Instance.new("BillboardGui")
        BillboardGui.Name = "Nametag"
        BillboardGui.Adornee = Head
        BillboardGui.Size = UDim2.new(0, 75, 0, 150)
        BillboardGui.StudsOffset = Vector3.new(0, 2, 0)
        BillboardGui.AlwaysOnTop = true
 
        local TextLabel = Instance.new("TextLabel")
        TextLabel.Size = UDim2.new(1, 0, 1, 0)
        TextLabel.Text = Player.Name
        TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White color
        TextLabel.BackgroundTransparency = 1
        TextLabel.TextStrokeTransparency = 0.75 -- Outline for better visibility
        TextLabel.Font = Enum.Font.Code
        TextLabel.TextScaled = true
        TextLabel.Parent = BillboardGui
 
        BillboardGui.Parent = Head
 
        -- Function to update visibility based on distance and toggle
        local function UpdateVisibility()
            if NametagsEnabled and Player.Character and Player.Character:FindFirstChild("Head") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
                local Distance = (Player.Character.Head.Position - LocalPlayer.Character.Head.Position).Magnitude
                BillboardGui.Enabled = (Distance <= MaxDistance)
            else
                BillboardGui.Enabled = false
            end
        end
 
        -- Monitor visibility
        local Connection
        Connection = RunService.Heartbeat:Connect(function()
            if Player.Character and Player.Character:FindFirstChild("Head") then
                UpdateVisibility()
            else
                BillboardGui:Destroy() -- Clean up nametag when player dies
                Connection:Disconnect()
            end
        end)
    end
 
    -- Apply when character spawns or respawns
    if Player.Character then
        SetupNametag(Player.Character)
    end
    Player.CharacterAdded:Connect(SetupNametag)
end
 
-- Function to apply ESP/Highlight to a player
local function ApplyHighlight(Player)
    if Player == LocalPlayer then return end -- Skip local player
 
    local function SetupHighlight(Character)
        -- Remove old highlights
        for _, v in pairs(Character:GetChildren()) do
            if v:IsA("Highlight") then
                v:Destroy()
            end
        end
 
        local Highlighter = Instance.new("Highlight")
        Highlighter.Parent = Character
 
        local function UpdateFillColor()
            local DefaultColor = Color3.fromRGB(255, 48, 51) -- Default red color
            Highlighter.FillColor = Player.TeamColor and Player.TeamColor.Color or DefaultColor
        end
 
        UpdateFillColor()
        Player:GetPropertyChangedSignal("TeamColor"):Connect(UpdateFillColor)
 
        -- Remove highlight when player dies
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            Humanoid.Died:Connect(function()
                Highlighter:Destroy()
            end)
        end
    end
 
    -- Apply highlight on spawn and respawn
    if Player.Character then
        SetupHighlight(Player.Character)
    end
    Player.CharacterAdded:Connect(SetupHighlight)
end
 
-- Function to toggle nametags
local function ToggleNametags()
    NametagsEnabled = not NametagsEnabled -- Flip the toggle state
    print("Nametags Enabled:", NametagsEnabled)
 
    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild("Head") then
            local Nametag = Player.Character.Head:FindFirstChild("Nametag")
            if Nametag then
                Nametag.Enabled = NametagsEnabled
            end
        end
    end
end
 
-- Bind the toggle function to the "B" key
UserInputService.InputBegan:Connect(function(Input, GameProcessed)
    if not GameProcessed and Input.KeyCode == Enum.KeyCode.LeftBracket then
        ToggleNametags()
    end
end)
 
-- Apply ESP and Nametags to all current players
for _, Player in pairs(Players:GetPlayers()) do
    CreateNametag(Player)
    ApplyHighlight(Player)
end
 
-- Apply ESP and Nametags to players who join later
Players.PlayerAdded:Connect(function(Player)
    CreateNametag(Player)
    ApplyHighlight(Player)
end)
   end,
})

local Button =MainTab:CreateButton({
   Name = " Box Esp",
   Callback = function()
        --// SETTINGS
local BOX_COLOR = Color3.fromRGB(0, 255, 0)
local TRACER_COLOR = Color3.fromRGB(255, 0, 0)
local SHOW_BOXES = true
local SHOW_TRACERS = False

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// STATE
local espObjects = {}

--// Cleanup Function
local function clearESP()
    for _, v in pairs(espObjects) do
        if v.box then v.box:Remove() end
        if v.tracer then v.tracer:Remove() end
    end
    espObjects = {}
end

--// ESP Drawing Function
local function drawESPForPlayer(player)
    if player == LocalPlayer then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local box = Drawing.new("Square")
    box.Color = BOX_COLOR
    box.Thickness = 2
    box.Filled = false
    box.Visible = false

    local tracer = Drawing.new("Line")
    tracer.Color = TRACER_COLOR
    tracer.Thickness = 2
    tracer.Visible = false

    espObjects[player] = {box = box, tracer = tracer}
end

--// Main ESP Loop
RunService.RenderStepped:Connect(function()
    -- Remove ESP for players who left
    for player, objs in pairs(espObjects) do
        if not Players:FindFirstChild(player.Name) or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if objs.box then objs.box:Remove() end
            if objs.tracer then objs.tracer:Remove() end
            espObjects[player] = nil
        end
    end

    -- Add ESP for new players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not espObjects[player] then
            drawESPForPlayer(player)
        end
    end

    -- Update ESP positions
    for player, objs in pairs(espObjects) do
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                -- Box
                if SHOW_BOXES and objs.box then
                    local size = math.clamp(3000 / (hrp.Position - Camera.CFrame.Position).Magnitude, 2, 30)
                    objs.box.Size = Vector2.new(size, size * 1.8)
                    objs.box.Position = Vector2.new(pos.X - size / 2, pos.Y - size * 1.1)
                    objs.box.Visible = true
                else
                    objs.box.Visible = false
                end
                -- Tracer
                if SHOW_TRACERS and objs.tracer then
                    objs.tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    objs.tracer.To = Vector2.new(pos.X, pos.Y)
                    objs.tracer.Visible = true
                else
                    objs.tracer.Visible = false
                end
            else
                if objs.box then objs.box.Visible = false end
                if objs.tracer then objs.tracer.Visible = false end
            end
        else
            if objs.box then objs.box.Visible = false end
            if objs.tracer then objs.tracer.Visible = false end
        end
    end
end)

--// Cleanup on leave
LocalPlayer.OnRemoving:Connect(clearESP)

   end,
})

local MainSection = MainTab:CreateSection("Teleports")

local Button = MainTab:CreateButton({
   Name = "Bank",
   Callback = function()
        --// SETTINGS
local BANK_POSITION = Vector3.new(-266.5, 22.15, -347.5) -- Bank entrance position

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToBank()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(BANK_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToBank()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Downhill GunStore",
   Callback = function()
        --// SETTINGS
local SCHOOL_POSITION = Vector3.new(-510, 22, -604) -- Approximate main entrance of the school

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToSchool()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(SCHOOL_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToSchool()


   end,
})

local Button = MainTab:CreateButton({
   Name = "Basketball Court",
   Callback = function()
       --// SETTINGS
local MILITARY_BASE_POSITION = Vector3.new(-932, 22, -552) -- Approximate main entrance of the military base

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToMilitaryBase()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(MILITARY_BASE_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToMilitaryBase()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Police Station",
   Callback = function()
        --// SETTINGS
local REVOLVER_SHOP_POSITION = Vector3.new(-387, 22, -97) -- Approximate position of the Revolver shop near the bank and jewelry store

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToRevolverShop()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(REVOLVER_SHOP_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToRevolverShop()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Revolver",
   Callback = function()
        --// SETTINGS
local DOWNHILL_GUNZ_POSITION = Vector3.new(-638, 22, -85) -- Approximate entrance of Downhill Gunz [1][3]

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToDownhill()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(DOWNHILL_GUNZ_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToDownhill()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Uphill Gunstore",
   Callback = function()
        --// SETTINGS
local UPHILL_GUNZ_POSITION = Vector3.new(481, 49, -613) -- Approximate entrance of Uphill Gunz[1][6]

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToUphillGunz()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(UPHILL_GUNZ_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToUphillGunz()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Double-Barrel Casino",
   Callback = function()
        --// SETTINGS
local WAREHOUSE_POSITION = Vector3.new(-875, 22, -300) -- Approximate main entrance of the warehouse

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToWarehouse()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(WAREHOUSE_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToWarehouse()

   end,
})

local Button = MainTab:CreateButton({
   Name = "TacoShop",
   Callback = function()
        --// SETTINGS
local TACOSHOP_POSITION = Vector3.new(573, 51, -485) -- Approximate entrance of Josie's Taco Restaurant (Uphill area)[1][4]

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToTacoShop()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(TACOSHOP_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToTacoShop()

   end,
})

local Button = MainTab:CreateButton({
   Name = "Tree House",
   Callback = function()
        --// SETTINGS
local HOOD_FITNESS_POSITION = Vector3.new(-95, 22, -278) -- Approximate entrance of Hood Fitness gym

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

--// Teleport Immediately
local function teleportToHoodFitness()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(HOOD_FITNESS_POSITION + Vector3.new(0, 3, 0)) -- Slightly above ground
    end
end

teleportToHoodFitness()

   end,
})

local MainTab = Window:CreateTab("🎯Target", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Targeting")

local Button = MainTab:CreateButton({
   Name = "Target Player (Covers Up Roblox Chat)",
   Callback = function()
        --// CREATE GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "SpectateGui"
ScreenGui.ResetOnSpawn = false

local TextBox = Instance.new("TextBox")
TextBox.Parent = ScreenGui
TextBox.Size = UDim2.new(0, 220, 0, 40)
TextBox.Position = UDim2.new(0, 20, 0, 20)
TextBox.PlaceholderText = "Enter player display name..."
TextBox.Text = ""
TextBox.Font = Enum.Font.SourceSans
TextBox.TextSize = 22
TextBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
TextBox.BorderSizePixel = 0

local ViewButton = Instance.new("TextButton")
ViewButton.Parent = ScreenGui
ViewButton.Size = UDim2.new(0, 100, 0, 40)
ViewButton.Position = UDim2.new(0, 250, 0, 20)
ViewButton.Text = "View"
ViewButton.Font = Enum.Font.SourceSansBold
ViewButton.TextSize = 22
ViewButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
ViewButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ViewButton.BorderSizePixel = 0

local UnviewButton = Instance.new("TextButton")
UnviewButton.Parent = ScreenGui
UnviewButton.Size = UDim2.new(0, 100, 0, 40)
UnviewButton.Position = UDim2.new(0, 360, 0, 20)
UnviewButton.Text = "Unview"
UnviewButton.Font = Enum.Font.SourceSansBold
UnviewButton.TextSize = 22
UnviewButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
UnviewButton.TextColor3 = Color3.fromRGB(255, 255, 255)
UnviewButton.BorderSizePixel = 0

local FlingButton = Instance.new("TextButton")
FlingButton.Parent = ScreenGui
FlingButton.Size = UDim2.new(0, 100, 0, 40)
FlingButton.Position = UDim2.new(0, 470, 0, 20)
FlingButton.Text = "Fling"
FlingButton.Font = Enum.Font.SourceSansBold
FlingButton.TextSize = 22
FlingButton.BackgroundColor3 = Color3.fromRGB(255, 170, 0)
FlingButton.TextColor3 = Color3.fromRGB(255, 255, 255)
FlingButton.BorderSizePixel = 0

-- Parent to CoreGui for universal visibility
local parentGui = game:GetService("CoreGui")
if not pcall(function() local _ = parentGui.Parent end) then
    parentGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
end
ScreenGui.Parent = parentGui

--// SERVICES
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")

--// STATE
local viewing = false
local originalSubject = Camera.CameraSubject
local viewTargetDisplayName = nil

--// GET TARGET PLAYER BY DISPLAY NAME FUNCTION
local function getTargetByDisplayName(displayName)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.DisplayName:lower() == displayName:lower() and plr.Character and plr.Character:FindFirstChild("Humanoid") then
            return plr
        end
    end
end

--// VIEW BUTTON CLICK: Start Viewing
ViewButton.MouseButton1Click:Connect(function()
    local displayName = TextBox.Text
    if displayName ~= "" then
        viewTargetDisplayName = displayName
        local target = getTargetByDisplayName(viewTargetDisplayName)
        if target then
            originalSubject = Camera.CameraSubject
            Camera.CameraSubject = target.Character.Humanoid
            viewing = true
            print("Now viewing:", target.DisplayName, "("..target.Name..")")
        else
            print("Player with that display name not found or not alive!")
        end
    end
end)

--// UNVIEW BUTTON CLICK: Stop Viewing
UnviewButton.MouseButton1Click:Connect(function()
    if viewing then
        viewing = false
        Camera.CameraSubject = originalSubject
        print("Stopped viewing.")
    end
end)

--// FLING BUTTON CLICK: Fling Target
FlingButton.MouseButton1Click:Connect(function()
    local displayName = TextBox.Text
    if displayName ~= "" then
        local target = getTargetByDisplayName(displayName)
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            -- Fling by applying a strong velocity
            local hrp = target.Character.HumanoidRootPart
            hrp.Velocity = Vector3.new(75, 200, 65) -- You can adjust the strength/direction
            print("Flinged:", target.DisplayName, "("..target.Name..")")
        else
            print("Player with that display name not found or not alive!")
        end
    end
end)

--// AUTO RETURN CAMERA IF TARGET LEAVES OR DIES
RunService.RenderStepped:Connect(function()
    if viewing and viewTargetDisplayName then
        local target = getTargetByDisplayName(viewTargetDisplayName)
        if not (target and target.Character and target.Character:FindFirstChild("Humanoid")) then
            viewing = false
            Camera.CameraSubject = originalSubject
            print("Stopped viewing; target left or died.")
        end
    end
end)

   end,
})

local MainTab = Window:CreateTab("🧍Character", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Character/Player")

local Button = MainTab:CreateButton({
   Name = "Fling Touch",
   Callback = function()
        -- Fling anyone who touches your character
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function flingTarget(targetChar)
    local hrp = targetChar:FindFirstChild("HumanoidRootPart")
    if hrp then
        -- Apply a strong random velocity for a troll effect
        hrp.Velocity = Vector3.new(
            math.random(-100,100),
            math.random(100,200),
            math.random(-100,100)
        )
        -- Optional: ragdoll them for extra effect
        local hum = targetChar:FindFirstChildOfClass("Humanoid")
        if hum then hum.Sit = true end
    end
end

local function onTouched(otherPart)
    local theirChar = otherPart.Parent
    if theirChar and theirChar ~= LocalPlayer.Character and theirChar:FindFirstChildOfClass("Humanoid") then
        flingTarget(theirChar)
    end
end

local function connectTouchFling()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            part.Touched:Connect(onTouched)
        end
    end
end

connectTouchFling()
LocalPlayer.CharacterAdded:Connect(connectTouchFling)

   end,
})

local Button = MainTab:CreateButton({
   Name = "White Character",
   Callback = function()
        -- White Character Outline Script
-- Works as a LocalScript or Script (for your own character)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Remove old outline if present
if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("WhiteOutline") then
    LocalPlayer.Character.WhiteOutline:Destroy()
end

-- Wait for character to load
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- Create the highlight (outline)
local highlight = Instance.new("Highlight")
highlight.Name = "WhiteOutline"
highlight.Adornee = char
highlight.Parent = char
highlight.FillTransparency = 1 -- Only outline, no fill
highlight.OutlineColor = Color3.new(1, 1, 1) -- White
highlight.OutlineTransparency = 0 -- Fully visible

-- Optional: Keep outline on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    task.wait(1)
    local newHighlight = Instance.new("Highlight")
    newHighlight.Name = "WhiteOutline"
    newHighlight.Adornee = newChar
    newHighlight.Parent = newChar
    newHighlight.FillTransparency = 1
    newHighlight.OutlineColor = Color3.new(1, 1, 1)
    newHighlight.OutlineTransparency = 0
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Headless (client Sided)",
   Callback = function()
        -- Client-Sided Headless Script for Roblox

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function makeHeadless(character)
    local head = character:FindFirstChild("Head")
    if head and head:IsA("BasePart") then
        head.Transparency = 1
        -- Hide face decal if it exists
        local face = head:FindFirstChildOfClass("Decal")
        if face then
            face.Transparency = 1
        end
    end
end

-- Apply headless on current character
if LocalPlayer.Character then
    makeHeadless(LocalPlayer.Character)
end

-- Apply headless on respawn
LocalPlayer.CharacterAdded:Connect(makeHeadless)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Rotating Crosshair",
   Callback = function()
        -- Rotating Crosshair Script for Roblox (Drawing API Required)

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- SETTINGS
local crosshairLength = 24
local crosshairThickness = 2
local crosshairColor = Color3.fromRGB(255, 255, 0)
local rotationSpeed = math.rad(90) -- degrees per second (change for faster/slower rotation)

-- Drawing lines for crosshair
local line1 = Drawing.new("Line")
local line2 = Drawing.new("Line")
for _, line in ipairs({line1, line2}) do
    line.Thickness = crosshairThickness
    line.Color = crosshairColor
    line.Transparency = 1
    line.Visible = true
end

local angle = 0
RunService.RenderStepped:Connect(function(dt)
    angle = (angle + rotationSpeed * dt) % (math.pi * 2)
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    local cosA, sinA = math.cos(angle), math.sin(angle)

    -- First line (rotated)
    local offset1 = Vector2.new(cosA, sinA) * crosshairLength
    line1.From = center - offset1
    line1.To = center + offset1

    -- Second line (perpendicular, rotated)
    local offset2 = Vector2.new(-sinA, cosA) * crosshairLength
    line2.From = center - offset2
    line2.To = center + offset2

    line1.Visible = true
    line2.Visible = true
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Double Jump",
   Callback = function()
        -- Double Jump Script (place in StarterCharacterScripts as a LocalScript)

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local maxJumps = 2 -- 2 = double jump, 3 = triple jump, etc.
local jumpCount = 0
local canDoubleJump = false
local humanoid

local function onCharacterAdded(character)
    humanoid = character:WaitForChild("Humanoid")
    jumpCount = 0
    canDoubleJump = true

    humanoid.StateChanged:Connect(function(_, newState)
        if newState == Enum.HumanoidStateType.Landed then
            jumpCount = 0
            canDoubleJump = true
        elseif newState == Enum.HumanoidStateType.Freefall then
            canDoubleJump = true
        end
    end)
end

if LocalPlayer.Character then
    onCharacterAdded(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

UserInputService.JumpRequest:Connect(function()
    if not humanoid or humanoid:GetState() == Enum.HumanoidStateType.Dead then return end

    if jumpCount < maxJumps then
        if jumpCount > 0 then
            -- Only apply extra jump force on the second jump (in air)
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        jumpCount = jumpCount + 1
    end
end)

   end,
})

local Button = MainTab:CreateButton({
   Name = "PP-stopsign",
   Callback = function()
        -- Da Hood Stop Sign Troll Script
-- Rapidly equips and swings your stop sign for trolling

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer:WaitForChild("Backpack")
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- Find the stop sign tool
local function getStopSign()
    return Backpack:FindFirstChild("StopSign") or Character:FindFirstChild("StopSign")
end

-- Equip and swing loop
while true do
    local stopSign = getStopSign()
    if stopSign then
        -- Equip if not already equipped
        if Backpack:FindFirstChild("StopSign") then
            LocalPlayer.Character.Humanoid:EquipTool(stopSign)
            task.wait(0.05)
        end
        -- Try to activate/swing the stop sign
        if Character:FindFirstChild("StopSign") then
            pcall(function()
                stopSign:Activate()
            end)
        end
    end
    task.wait(0.15) -- Adjust for faster/slower trolling
end

   end,
})

local Button = MainTab:CreateButton({
   Name = "Rainbow-Character",
   Callback = function()
        -- Rainbow Character Script (Client-Sided, works for R6 and R15)
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Function to apply rainbow effect to all parts and accessories
local function rainbowify(character)
    -- Gather all parts to color
    local parts = {}
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            table.insert(parts, part)
        end
    end
    -- Accessories (hats, hair, etc.)
    for _, accessory in ipairs(character:GetChildren()) do
        if accessory:IsA("Accessory") and accessory:FindFirstChild("Handle") then
            table.insert(parts, accessory.Handle)
        end
    end

    -- Start the rainbow loop for this character
    coroutine.wrap(function()
        while character.Parent do
            local hue = (tick() % 6) / 6 -- cycles from 0 to 1
            local color = Color3.fromHSV(hue, 1, 1)
            for _, part in ipairs(parts) do
                if part and part.Parent then
                    part.Color = color
                end
            end
            task.wait(0.03)
        end
    end)()
end

-- Apply on current character
if LocalPlayer.Character then
    rainbowify(LocalPlayer.Character)
end

-- Re-apply on respawn
LocalPlayer.CharacterAdded:Connect(rainbowify)

   end,
})

local Button = MainTab:CreateButton({
   Name = "Skin Changer (guns)",
   Callback = function()
        -- Da Hood Skin Changer Script (Client-Sided)
-- Works for most guns; only you see the changed skin

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- List of available skin names (examples, may vary by update)
local availableSkins = {
    "Galactic",
    "Red Skull",
    "Hello Kitty",
    "Heaven",
    "Golden Age",
    "Soul",
    "Toy",
    "Hoodmas",
    "Mystical",
    "Fire",
    "Electric",
    -- add more as found in the game
}

-- Change this to the skin you want
local desiredSkin = "Galactic" -- Example: "Galactic", "Red Skull", etc.

-- Function to apply skin to all your guns
local function applySkin(skinName)
    for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("GunScript_Local") then
            local skin = tool:FindFirstChild("Skin")
            if skin then
                skin.Value = skinName
            end
        end
    end
    for _, tool in ipairs(LocalPlayer.Character:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("GunScript_Local") then
            local skin = tool:FindFirstChild("Skin")
            if skin then
                skin.Value = skinName
            end
        end
    end
end

-- Apply on script run
applySkin(desiredSkin)

-- Optional: Re-apply every few seconds in case you pick up new guns
while true do
    applySkin(desiredSkin)
    task.wait(5)
end

   end,
})

local MainTab = Window:CreateTab("🛜Toggles", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Toggles")

local Toggle = MainTab:CreateToggle({
   Name = "Super-Jump (G)",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(superJumpPower)
        -- Super Jump Script with Toggle (default key: G)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

local superJumpPower = 150 -- Change this value for higher/lower jumps
local superJumpEnabled = false
local toggleKey = Enum.KeyCode.G

-- Toggle key handler
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == toggleKey then
        superJumpEnabled = not superJumpEnabled
        print("Super Jump is now " .. (superJumpEnabled and "ENABLED" or "DISABLED"))
    end
end)

-- Super jump logic
UserInputService.JumpRequest:Connect(function()
    if superJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        humanoid.UseJumpPower = true
        humanoid.JumpPower = superJumpPower
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

   end,
})
